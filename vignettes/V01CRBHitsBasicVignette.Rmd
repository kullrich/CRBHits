---
title: "CRBHits Basic Vignette"
author: "Kristian K Ullrich"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{CRBHits Basic Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Table of Contents

1. [Installation](#install)
2. [Conditional Reciprocal Best Hits](#crbh)
    1. [Conditional Reciprocal Best Hits - Algorithm](#crbhalgorithm)
    2. [Coding Sequences Input](#input)
    3. [cds2rbh() Function](#cds2rbhfunction)
    4. [Filter blast-like output prior fitting](#filters)
    5. [Custom Filter](#customfilters)
    6. [Fitting Parameter](#fittingparam)
3. [dN/dS Calculations](#dNdS)
    1. [Codon Alignments - cds2codonaln() Function](#cds2codon)
    2. [cds2kaks() Function](#cds2kaks)
    3. [rbh2kaks() Function](#rbh2kaks)
4. [References](#references)

[CRBHits](https://gitlab.gwdg.de/mpievolbio-it/crbhits) is a reimplementation of the Conditional Reciprocal Best Hit algorithm [crb-blast](https://github.com/cboursnell/crb-blast) in R.

## 1. [Installation]{#install}

See the R package page for a detailed description of the install process and its dependencies [https://mpievolbio-it.pages.gwdg.de/crbhits/](https://mpievolbio-it.pages.gwdg.de/crbhits/).

```
#see a detailed description of installation prerequisites at
#https://mpievolbio-it.pages.gwdg.de/crbhits/
library(devtools)
#from gitlab
install_gitlab("mpievolbio-it/crbhits", host = "https://gitlab.gwdg.de",
               build_vignettes = TRUE, dependencies = FALSE)
#from github
install_github("kullrich/CRBHits", build_vignettes = TRUE, dependencies = FALSE)
```

[CRBHits](https://gitlab.gwdg.de/mpievolbio-it/crbhits) needs [LAST](http://last.cbrc.jp/) and [KaKs_Calculator2.0](https://sourceforge.net/projects/kakscalculator2/files/KaKs_Calculator2.0.tar.gz/download) to be installed before one can efficiently use it.

Both prerequisites (LAST, KaKs_Calculator2.0) are forked within [CRBHits](https://gitlab.gwdg.de/mpievolbio-it/crbhits) and can be compiled for Linux/Unix/macOS with the functions `make.last()` and `make.KaKs_Calculator2()`.

For the windows platform the user needs to use e.g. [https://www.cygwin.com/](https://www.cygwin.com/) to be able to compile both prerequisites.

```
library(CRBHits)
#compile last-1080
make.last()
#compile KaKs_Calculator2.0
make.KaKs_Calculator2()
```

__Note:__

In this Vignette the `lastpath` is defined as `vignette.paths[1]` and the `kakscalcpath` as `vignette.paths[2]` to be able to build the Vignette.

However, once you have compiled last-1080 and KaKs_Calculator2.0 with the functions `make.last()` and `make.KaKs_Calculator2()` you won't need to specify the paths anymore. Please remove them if you would like to repeat the examples.

## 2. [Conditional Reciprocal Best Hits]{#crbh}

[CRBHits](https://gitlab.gwdg.de/mpievolbio-it/crbhits) is a reimplementation of the Conditional Reciprocal Best Hit algorithm [crb-blast](https://github.com/cboursnell/crb-blast) in R.

### 2.1 [Conditional Reciprocal Best Hits - Algorithm]{#crbhalgorithm}

The algorithm was introduced by [Aubry S, Kelly S et al. (2014)](http://www.plosgenetics.org/article/info%3Adoi%2F10.1371%2Fjournal.pgen.1004365) and ported to python [shmlast](https://pypi.org/project/shmlast/) ([Scott C. 2017](https://joss.theoj.org/papers/10.21105/joss.00142)) which benefits from the blast-like sequence search software [LAST](http://last.cbrc.jp/) ([Kie≈Çbasa SM et al. 2011](https://genome.cshlp.org/content/21/3/487.long)).

The CRBH algorithm builds upon the classical reciprocal best hit (RBH) approach to find orthologous sequences between two sets of sequences by defining an expect-value cutoff per alignment length. Further, this cutoff is used to retain secondary hits as additional bona-fide homologs.

[CRBHits](https://gitlab.gwdg.de/mpievolbio-it/crbhits) only takes coding nucleotide sequences as the query and target inputs.

__Why?__ Because [CRBHits](https://gitlab.gwdg.de/mpievolbio-it/crbhits) is implemented to use the same input afterwards to calculate synonymous and nonsynonymous substitutions which must match the protein sequences used during the conditional reciprocal best hit step.

### 2.2 [Coding Sequences Input]{#input}

One can either use **raw** or **gzipped** coding sequences **fasta** files as inputs with the `cdsfile2rbh()` function or use a `DNAStringSet` vector from the `Biostrings` R package with the `cds2rbh()` function.

[CRBHits](https://gitlab.gwdg.de/mpievolbio-it/crbhits) uses either the function `cdsfile2aafile()` to translate a coding sequence fasta file into its corresponding protein sequence fasta file or `cds2aa()` to translate a `DNAStringSet` into a `AAStringSet`. Thereby it removes all sequences that are not a multiple of three which can not be parsed corecctly.

__Note:__ The user can easily check if all coding sequences would be a multiple of three or rely on the input files generated by other sources.

```{r}
library(CRBHits)
#compile LAST and KaKs_Calculator2.0 for the vignette
vignette.paths <- make.vignette()

#example how to check coding sequences if all are a mutiple of three
cdsfile <- system.file("fasta", "ath.cds.fasta.gz", package = "CRBHits")
cds <- Biostrings::readDNAStringSet(cdsfile)

#the following statement should return TRUE, if all sequences are a mutiple of three
all(Biostrings::width(cds) %% 3 == 0)
```

The blast-like software [LAST](http://last.cbrc.jp/) is used to compare the translated coding sequences against each other and output a blast-like output table including the query and target length.

### 2.3 [cds2rbh() Function]{#cds2rbhfunction}

Like [shmlast](https://pypi.org/project/shmlast/), [CRBHits](https://gitlab.gwdg.de/mpievolbio-it/crbhits) plots the fitted model of the conditional reciprocal best hit evalue based algorithm.

```{r}
#example how to get crbh from two coding fasta files
cdsfile1 <- system.file("fasta", "ath.cds.fasta.gz", package = "CRBHits")
cdsfile2 <- system.file("fasta", "aly.cds.fasta.gz", package = "CRBHits")

cds1 <- Biostrings::readDNAStringSet(cdsfile1)
cds2 <- Biostrings::readDNAStringSet(cdsfile2)

#the following function calculates crbh matrix using one thread and plots the fitted curve
ath_aly_crbh <- cds2rbh(cds1, cds2, plotCurve = TRUE,
                        lastpath = vignette.paths[1])
summary(ath_aly_crbh)
```

Classical RBH can be performed by disabeling the `crbh` `@param`of the `cds2rbh()` or `cdsfile2rbh()` function.

```{r}
#example how to perform classical rbh
ath_aly_rbh <- cds2rbh(cds1, cds2, crbh = FALSE,
                       lastpath = vignette.paths[1])
```

Both, `cdsfile2rbh()` and `cds2rbh()` function, return a list of three `data.frame`'s which contain the conditional reciprocal best hit pairs (`$crbh.pairs`) retained, the query > target blast-like output matrix (`$crbh1`) and the target > query blast-like output matrix (`$crbh2`). For each matrix the `$rbh_class` indicates if the hit is a reciprocal best hit (`rbh`) or if it is a secondary hit retained because of crbh (`sec`). 

```{r}
#show dimension and first retained hit pairs
dim(ath_aly_crbh$crbh.pairs)
head(ath_aly_crbh$crbh.pairs)

#show first retained hit pairs for the query > target matrix
head(ath_aly_crbh$crbh1)

#get the number of rbh and sec hit pairs
table(ath_aly_crbh$crbh1$rbh_class)
table(ath_aly_crbh$crbh2$rbh_class)
```

If the `@param` `crbh` was set to `TRUE`, the conditional reciprocal best hit algorithm was applied and the fitting function will also be returned. The fitting function can than be used for manual plotting.

```{r}
#example how to use the fitting function for manual plotting
curve(ath_aly_crbh$rbh1_rbh2_fit(x),
      from = 1,
      to = 1000,
      xlab = "alnlength",
      ylab = "-log10(evalue)",
      main = "CRBH fitting")
```

One can also specify if a hit pair which is only found in one direction should be retained, which will be classified as (`single`).

```{r}
#example how to retain single direction secondary homologs
ath_aly_crbh <- cds2rbh(cds1, cds2, plotCurve = TRUE, keepSingleDirection = TRUE,
                        lastpath = vignette.paths[1])
table(ath_aly_crbh$crbh1$rbh_class)
table(ath_aly_crbh$crbh2$rbh_class)
dim(ath_aly_crbh)
```

### 2.4 [Filter blast-like output prior fitting]{#filters}

In addition users can filter the hit pairs prior fitting for other cirteria like evalue, protein identity and/or the twilight zone of protein sequence alignments according to [Rost B. (1999)](https://academic.oup.com/peds/article/12/2/85/1550637).

The follwoing filters are already defined can be used out of the box:

- evalue (`@param` `evalue = 0.001`)
- query coverage (`@param` `qcov = 0.5`)
- target coverage (`@param` `tcov = 0.5`)
- protein identity (`@param` `pident = 50`)
- alignment length (`@param` `alnlen = 50`)
- rost1999 (`@param` `rost1999 = TRUE`)

Taking the length of the obtained pairwise protein alignment one can calculate for each hit pair the query coverage as $\frac{alignment length}{query length}$.

The data will be filtered with a query coverage of 50\% (`cds2rbh(..., qcov = 0.5)`).

```{r}
#example how to filter prior crbh for query coverage
ath_aly_crbh <- cds2rbh(cds1, cds2, plotCurve = TRUE, qcov = 0.5,
                        lastpath = vignette.paths[1])
dim(ath_aly_crbh$crbh.pairs)
```

The implemented `rost1999` filter uses `equation2` of [Rost B. (1999)](https://academic.oup.com/peds/article/12/2/85/1550637)

$$f(x_{\text{hit pair}}) = \cases {100 \text{ , for } L_{\text{hit pair}} < 11 \\ 480 * L^{-0.32 * (1 + e^{\frac{-L}{1000}})} \text{ , for } L_{\text{hit pair}} \leq 450 \\ 19.5 \text{ , for } L_{\text{hit pair}} > 450}$$
, where $x_{\text{hit pair}}$ is the expected protein identity given the alignemnet length $L_{\text{hit pair}}$. If the actual $pident_{\text{hit pair}} >= f(x_{\text{hit pair}})$ the hit pair is retained.

```{r}
#define eq2 from Rost (1999)
get_pident_by_length <- function(x){
  eq2 <- function(L){
    if(L <= 11){return(100)}
    if(L <= 450){return(480*(L^(-0.32*(1+(exp(-L/1000))))))}
    if(L > 450){return(19.5)}
  }
  return(unlist(lapply(x, eq2)))
}

#plot expected pident by alignment length using eq2 from Rost (1999)
curve(get_pident_by_length, 11, 500, pch = 20, xlab = "alignment length", ylab = "pident",
      main = "expected protein identity (eq2; Rost B. 1999)")
```

This can be directly used by the `@param` `rost1999` set to `TRUE`.

```{r}
#example how to filter prior crbh for eq2 from Rost (1999)
ath_aly_crbh <- cds2rbh(cds1, cds2, plotCurve = TRUE, rost1999 = TRUE,
                        lastpath = vignette.paths[1])
dim(ath_aly_crbh$crbh.pairs)
```

### 2.5 [Custom Filter]{#filters}

The user can also define its own function to filter the blast-like output prior crbh.

```{r}
#example for a custom filter for e.g. bit score (column 12)
myfilter <- function(rbh, value = 500.0){
  return(rbh[as.numeric(rbh[, 12]) >= value , , drop = FALSE])
}

#example how to filter prior crbh with a custom filter
ath_aly_crbh <- cds2rbh(cds1, cds2, plotCurve = TRUE, filter = list(myfilter),
                        lastpath = vignette.paths[1])
dim(ath_aly_crbh$crbh.pairs)
```

### 2.6. [Fitting Parameter]{#fittingparam}

The original implementation of the Conditional Reciprocal Best Hit algorithm [crb-blast.rb line 438-518](https://github.com/cboursnell/crb-blast/blob/master/lib/crb-blast/crb-blast.rb) uses certain parameters for fitting the evalue against the alignment length.

In brief, for each retained reciprocal hit pair (RBH; after filtering) the evalue and the corresponding alignment length of a hit pair and its neighborhood is evaluated. The neighborhood is defined by a weighting parameter of the alignment length (default is set to `@param` `fit.varweight = 0.1`) and a minimum neighborhood alignment length (default is set to `@param` `fit.min = 5`).

For each unique alignment length $L$ a value $s_{L}$ is defined as the neighborhood alignment length as

$$s_{L} = \cases {\text{fit.min} \text{ , for } L * \text{fit.varweight} < \text{fit.min} \\ L * \text{fit.varweight} \text{ , for } L * \text{fit.varweight} \geq \text{fit.min}}$$
E.g. for an alignment length of 100 and the default settings, $s_{100} = 100 * 0.1 = 10$.

All RBHs, for which $L-s_{L} \leq L_{RBH_i} \leq L + s_{L}$, in other words, for which their alignment lengths fall between 90 and 110 are than considered for fitting a cutoff at that alignment length using the mean of the $-log10(evalue)$.

$$\text{cutoff}_{L} = \frac{1}{n} \sum_{i = 1}^{n}{\cases{324 \text{ , for }  evalue_{RBH_i} = 0 \\ -log10(evalue_{\text{RBH}_i}) \text{ , for } evalue_{RBH_i} \ne 0}}$$

The user can now alter between `mean` and `median` using the `@param` `fit.type = "mean"` or `fit.type = "median"` to get alternative fitting curves.

```{r}
#example how to get crbh from two coding fasta files using median fitting
ath_aly_crbh <- cds2rbh(cds1, cds2, plotCurve = TRUE,
                        fit.type = "median",
                        lastpath = vignette.paths[1])
```

## 3. [dN/dS Calculations]{#dNdS}

### 3.1. [Codon Alignments - cds2codonaln() Function]{#cds2codon}

To be able to calculate synonymous and non-synonymous substitutions, one needs to use a codon alignment.

The `cds2codonaln()` function takes two single nucleotide sequences as input to obtain such a codon alignment. The function will convert the nucleotide sequences into amino acid sequences, align them with the help of the `pairwiseAlignment()` function from the `Biostrings` R package and convert this alignment back into a codon alignment.

```{r}
#example to get a codon alignment
cds1 <- Biostrings::DNAString("ATGCAACATTGC")
cds2 <- Biostrings::DNAString("ATGCATTGC")
cds2codonaln(cds1, cds2)
```

The user can alter some `@param` to change the alignment parameters, like `type`, `substitutionMatrix`, `gapOpening` and `gapExtension` costs as defined by the `pairwiseAlignment()` function from the `Biostrings` R package.

```{r}
#example to alter the substitionMatrix and use the BLOSUM45 cost matrix
cds2codonaln(cds1, cds2, substitutionMatrix = "BLOSUM45")
```

The user can also remove gaps in the codon alignment.

```{r}
#example to remove codon gaps
cds2codonaln(cds1, cds2, remove.gaps = TRUE)
```

### 3.2. [cds2kaks() Function]{#cds2kaks}

The ka/ks (dN/dS) values can be obtained either via the codon model of [Li WH. (1999)](https://www.ncbi.nlm.nih.gov/pubmed/8433381) implemented in the R package [seqinr](https://cran.r-project.org/web/packages/seqinr/index.html) or the model [Yang Z and Nielson R. (2000)](https://www.ncbi.nlm.nih.gov/pubmed/10666704) implemented in [KaKs_Calculator2.0](https://sourceforge.net/projects/kakscalculator2/files/KaKs_Calculator2.0.tar.gz/download) (see [Quick Installation](#quickinstall) how to compile the prerequisites).

The `cds2kaks()` function takes two single nucleotide sequences as input to obtain a codon alignment and calculate dN/dS.

```{r}
##load example sequence data
data("ath", package="CRBHits")
data("aly", package="CRBHits")
##select a sequence pair according to a best hit pair (done for you)
cds1 <- ath[1]
cds2 <- aly[282]
cds2kaks(cds1, cds2, model = "Li")
```

All parameters which can be used by the `cds2codonaln()` function can be overgiven to e.g. use an alternative `substitutionMatrix`.

```{r}
#example to use an alternative substitutionMatrix
cds2kaks(cds1, cds2, model = "Li", substitutionMatrix = "BLOSUM45")
```

### 3.3. [rbh2kaks() Function]{#rbh2kaks}

The resultings conditional reciprocal best hit pair matrix (see [cds2rbh()](#cds2rbhfunction)) can be used with the `rbh2kaks()` function to obtain pairwise codon alignments, which are further used to calculate synonymous and nonsynonymous substitutions using parallelization.

__Note:__

It is important, that the names of the `rbh` columns must match the names of the corresponding `cds1` and `cds2` `DNAStringSet` vectors.

However, since one should directly use the same input `DNAStringSet` vector or input `url` to calculate the reciprocal best hit pair matrix with the `cds2rbh()` or the `cdsfile2rbh()` function, this should not be a problem.

```{r}
#example how to get crbh from two coding fasta files
cdsfile1 <- system.file("fasta", "ath.cds.fasta.gz", package = "CRBHits")
cdsfile2 <- system.file("fasta", "aly.cds.fasta.gz", package = "CRBHits")

cds1 <- Biostrings::readDNAStringSet(cdsfile1)
cds2 <- Biostrings::readDNAStringSet(cdsfile2)

#the following function calculates crbh matrix using one thread and plots the fitted curve
ath_aly_crbh <- cds2rbh(cds1, cds2,
                        lastpath = vignette.paths[1])

#calculate dN/dS usign the crbh matrix
ath_aly_crbh.kaks <- rbh2kaks(ath_aly_crbh$crbh.pairs[1:20, ],
                              cds1, cds2, model = "Li")
head(ath_aly_crbh.kaks)
```

The dN/dS calculations can be parallelized.

```{r}
#calculate dN/dS usign the crbh matrix and multiple threads
ath_aly_crbh.kaks <- rbh2kaks(ath_aly_crbh$crbh.pairs[1:20, ],
                              cds1, cds2, model = "Li", threads = 2)
head(ath_aly_crbh.kaks)
```

Like for the `cds2kaks()` function, all parameters which can be used by the `cds2codonaln()` function can be overgiven to e.g. use an alternative `substitutionMatrix`.

```{r}
#calculate dN/dS usign the crbh matrix and multiple threads
ath_aly_crbh.kaks <- rbh2kaks(ath_aly_crbh$crbh.pairs[1:20, ],
                              cds1, cds2, model = "Li", threads = 2,
                              substitutionMatrix = "BLOSUM45")
head(ath_aly_crbh.kaks)
```

## 4. [References]{#references}

Aubry S., Kelly S., K√ºmpers B. M., Smith-Unna R. D., and Hibberd J. M. (2014). **Deep evolutionary comparison of gene expression identifies parallel recruitment of trans-factors in two independent origins of C4 photosynthesis.** *PLoS genetics*, **10(6)**. [https://doi.org/10.1371/journal.pgen.1004365](https://doi.org/10.1371/journal.pgen.1004365)

Charif D., and Lobry J. R. (2007). **SeqinR 1.0-2: a contributed package to the R project for statistical computing devoted to biological sequences retrieval and analysis.** *In Structural approaches to sequence evolution* (pp. 207-232). Springer, Berlin, Heidelberg. [https://link.springer.com/chapter/10.1007/978-3-540-35306-5_10](https://link.springer.com/chapter/10.1007/978-3-540-35306-5_10)

Kie≈Çbasa S. M., Wan R., Sato K., Horton P., and Frith M. C. (2011). **Adaptive seeds tame genomic sequence comparison.** *Genome research*, 21(3), 487-493. [https://doi.org/10.1101/gr.113985.110](https://doi.org/10.1101/gr.113985.110)

Li W. H. (1993). **Unbiased estimation of the rates of synonymous and nonsynonymous substitution.** *Journal of molecular evolution*, 36(1), 96-99. [https://doi.org/10.1007/bf02407308](https://doi.org/10.1007/bf02407308)

Pag√®s H., Aboyoun P., Gentleman R., and DebRoy S. (2017). **Biostrings: Efficient manipulation of biological strings.** *R package version*, 2(0).

Rost B. (1999). **Twilight zone of protein sequence alignments.** *Protein engineering*, 12(2), 85-94. [https://doi.org/10.1093/protein/12.2.85](https://doi.org/10.1093/protein/12.2.85)

Scott C. (2017). **shmlast: an improved implementation of conditional reciprocal best hits with LAST and Python.** *Journal of Open Source Software*, 2(9), 142. [https://joss.theoj.org/papers/10.21105/joss.00142](https://joss.theoj.org/papers/10.21105/joss.00142)

Yang Z., and Nielsen R. (2000). **Estimating synonymous and nonsynonymous substitution rates under realistic evolutionary models.** *Molecular biology and evolution*, 17(1), 32-43. [https://doi.org/10.1093/oxfordjournals.molbev.a026236](https://doi.org/10.1093/oxfordjournals.molbev.a026236)
